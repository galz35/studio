/**
 * Core Philosophy: This ruleset implements a Database-Based Access Control (DBAC) model for a corporate medical application.
 * Authorization is primarily determined by a user's 'rol' (role) stored within their document in the /usuariosAplicacion collection.
 * There are three main roles:
 *  - PACIENTE: Can only access their own associated medical data.
 *  - MEDICO: Has broad read and write access to all patient-related clinical data.
 *  - ADMIN: Has broad access similar to a MEDICO, with additional permissions to manage user and doctor records.
 *
 * Data Structure: The database uses a flat, root-level collection structure. This design avoids complex hierarchical security rules
 * and improves performance by minimizing the need for nested 'get' calls. Each collection represents a distinct data entity.
 *
 * Key Security Decisions:
 * - User and medical professional data (/pacientes, /medicos) is managed by ADMINs.
 * - Patients can create their own wellness checks and initial clinical cases, but only medical staff (MEDICO, ADMIN) can create
 *   official medical records like appointments, attentions, exams, and follow-ups.
 * - All sensitive patient data collections cannot be listed by patients to prevent data leakage. Only MEDICO and ADMIN roles can list these records.
 * - The /empleadosEmp2024 collection is treated as read-only data, likely synchronized from an external system.
 *
 * Developer Responsibility:
 * The security of this application critically depends on the correct creation of a `/usuariosAplicacion/{userId}` document for each user.
 * Your backend logic MUST ensure that when a user signs up, this document is created with the correct `rol` and, if applicable, the
 * corresponding `idPaciente` or `idMedico`. This document is the source of truth for all subsequent authorization decisions.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Returns the signed-in user's profile document from the 'usuariosAplicacion' collection.
     * This is the foundation of the Database-Based Access Control (DBAC) model.
     */
    function userProfile() {
      return get(/databases/$(database)/documents/usuariosAplicacion/$(request.auth.uid));
    }

    /**
     * Returns the role ('PACIENTE', 'MEDICO', 'ADMIN') of the signed-in user from their profile.
     */
    function userRole() {
      return userProfile().data.rol;
    }

    /**
     * Checks if a user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the request comes from an authenticated user whose UID matches the document's ID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if the document being accessed already exists.
     * Crucial for protecting against writes on non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the signed-in user has the 'ADMIN' role.
     */
    function isAdmin() {
      return isSignedIn() && userRole() == 'ADMIN';
    }

    /**
     * Checks if the signed-in user has the 'MEDICO' role.
     */
    function isMedico() {
      return isSignedIn() && userRole() == 'MEDICO';
    }

    /**
     * Checks if the signed-in user is a patient and their profile's 'idPaciente'
     * matches the provided patient ID.
     */
    function isOwnPaciente(pacienteId) {
      return isSignedIn() && userProfile().data.idPaciente == pacienteId;
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Manages application user profiles. Users can create and manage their own profile. Admins can manage any user profile.
     * @path /usuariosAplicacion/{idUsuario}
     * @allow (create) A new user creating their own profile document: `auth.uid == idUsuario`.
     * @deny (update) A user trying to update another user's profile.
     * @principle Enforces self-service for user profiles and administrative override.
     */
    match /usuariosAplicacion/{idUsuario} {
      allow get: if isOwner(idUsuario) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(idUsuario);
      allow update: if (isOwner(idUsuario) || isAdmin()) && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores patient information. Readable by the patient themselves, doctors, and admins. Writable only by admins.
     * @path /pacientes/{idPaciente}
     * @allow (get) A patient fetching their own patient record via their linked profile.
     * @deny (list) A patient trying to list all other patients in the system.
     * @principle Restricts access to sensitive patient data to authorized roles and the patient themselves.
     */
    match /pacientes/{idPaciente} {
      allow get: if isOwnPaciente(idPaciente) || isMedico() || isAdmin();
      allow list: if isMedico() || isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores doctor information. This data is considered public to all authenticated users for purposes like booking. Writable only by admins.
     * @path /medicos/{idMedico}
     * @allow (get, list) Any authenticated user (e.g., a patient) can view doctor profiles.
     * @deny (create) A non-admin user trying to add a new doctor.
     * @principle Allows public read access for discoverability while centralizing management under admins.
     */
    match /medicos/{idMedico} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores patient-submitted wellness checks. Patients can manage their own checks. Doctors and admins have read-only access.
     * @path /chequeosBienestar/{idChequeo}
     * @allow (create) A patient creating a wellness check for themselves, ensuring the `idPaciente` in the document matches their profile.
     * @deny (update) A patient trying to change the `idPaciente` on an existing check.
     * @principle Validates relational integrity to ensure patients can only create records for themselves.
     */
    match /chequeosBienestar/{idChequeo} {
      allow get: if isOwnPaciente(resource.data.idPaciente) || isMedico() || isAdmin();
      allow list: if isMedico() || isAdmin();
      allow create: if isOwnPaciente(request.resource.data.idPaciente);
      allow update: if isOwnPaciente(resource.data.idPaciente) && isExistingDoc() && request.resource.data.idPaciente == resource.data.idPaciente;
      allow delete: if isOwnPaciente(resource.data.idPaciente) && isExistingDoc();
    }

    /**
     * @description Stores clinical cases. Patients can create and view their own cases. Doctors and admins have broader access.
     * @path /casosClinicos/{idCaso}
     * @allow (create) A patient creating a clinical case, linking it to their own `idPaciente`.
     * @deny (delete) A patient trying to delete a clinical case (should be archived by a doctor/admin).
     * @principle Enforces ownership on creation and allows medical staff to manage the case lifecycle.
     */
    match /casosClinicos/{idCaso} {
      allow get: if isOwnPaciente(resource.data.idPaciente) || isMedico() || isAdmin();
      allow list: if isMedico() || isAdmin();
      allow create: if isOwnPaciente(request.resource.data.idPaciente);
      allow update: if (isOwnPaciente(resource.data.idPaciente) || isMedico() || isAdmin()) && isExistingDoc() && request.resource.data.idPaciente == resource.data.idPaciente;
      allow delete: if (isMedico() || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores medical appointments. Readable by the involved patient, doctor, or an admin. Writable only by medical staff.
     * @path /citasMedicas/{idCita}
     * @allow (get) A patient viewing their own appointment details.
     * @deny (create) A patient trying to create a medical appointment directly.
     * @principle Access is granted to collaborators (patient, doctor) while write operations are restricted to medical professionals.
     */
    match /citasMedicas/{idCita} {
      allow get: if isOwnPaciente(resource.data.idPaciente) || isMedico() || isAdmin();
      allow list: if isMedico() || isAdmin();
      allow create: if isMedico() || isAdmin();
      allow update: if (isMedico() || isAdmin()) && isExistingDoc();
      allow delete: if (isMedico() || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores records of medical care provided. This is highly sensitive. Readable by the patient; writable only by medical staff.
     * @path /atencionesMedicas/{idAtencion}
     * @allow (get) A patient viewing a medical attention record linked to one of their clinical cases.
     * @deny (create, update, delete) A patient trying to modify their own medical attention record.
     * @principle Protects the integrity of clinical records by restricting writes to authorized medical personnel.
     */
    match /atencionesMedicas/{idAtencion} {
      allow get: if isOwnPaciente(get(/databases/$(database)/documents/casosClinicos/$(resource.data.idCaso)).data.idPaciente) || isMedico() || isAdmin();
      allow list: if isMedico() || isAdmin();
      allow create: if isMedico() || isAdmin();
      allow update: if (isMedico() || isAdmin()) && isExistingDoc();
      allow delete: if (isMedico() || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores results of medical exams. Readable by the patient; writable only by medical staff.
     * @path /examenesMedicos/{idExamen}
     * @allow (get) A patient viewing their exam results.
     * @deny (create) A patient trying to upload their own exam results.
     * @principle Ensures that official medical exam records are created and managed only by trusted staff.
     */
    match /examenesMedicos/{idExamen} {
      allow get: if isOwnPaciente(resource.data.idPaciente) || isMedico() || isAdmin();
      allow list: if isMedico() || isAdmin();
      allow create: if isMedico() || isAdmin();
      allow update: if (isMedico() || isAdmin()) && isExistingDoc();
      allow delete: if (isMedico() || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores patient follow-up notes and schedules. Readable by the patient; writable only by medical staff.
     * @path /seguimientosPacientes/{idSeguimiento}
     * @allow (get) A patient checking the notes from their last follow-up call.
     * @deny (update) A patient trying to change the status of their follow-up.
     * @principle Secures the follow-up process, ensuring it's managed by the medical team.
     */
    match /seguimientosPacientes/{idSeguimiento} {
      allow get: if isOwnPaciente(resource.data.idPaciente) || isMedico() || isAdmin();
      allow list: if isMedico() || isAdmin();
      allow create: if isMedico() || isAdmin();
      allow update: if (isMedico() || isAdmin()) && isExistingDoc();
      allow delete: if (isMedico() || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Read-only collection of employee data, likely from an external HR system.
     * @path /empleadosEmp2024/{carnet}
     * @allow (get, list) Any authenticated user can read this data.
     * @deny (create, update, delete) All write operations are blocked to maintain data integrity from the source system.
     * @principle Enforces a one-way data flow for externally managed information.
     */
    match /empleadosEmp2024/{carnet} {
      allow get, list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Stores audit and error logs. Writable by any authenticated user, readable only by admins.
     * @path /logs/{logId}
     * @allow (create) Any authenticated user can write a log entry (e.g., log a login attempt or an error).
     * @deny (read, update, delete) Prevents users from reading or tampering with logs. Admins have full read access.
     * @principle Allows for comprehensive auditing while maintaining the integrity and confidentiality of log data.
     */
    match /logs/{logId} {
        allow create: if isSignedIn();
        allow get, list: if isAdmin();
        allow update, delete: if false;
    }
  }
}
